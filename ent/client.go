// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/balaji-balu/margo-hello-world/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/balaji-balu/margo-hello-world/ent/applicationdesc"
	"github.com/balaji-balu/margo-hello-world/ent/component"
	"github.com/balaji-balu/margo-hello-world/ent/deploymentprofile"
	"github.com/balaji-balu/margo-hello-world/ent/host"
	"github.com/balaji-balu/margo-hello-world/ent/orchestrator"
	"github.com/balaji-balu/margo-hello-world/ent/site"
	"github.com/balaji-balu/margo-hello-world/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ApplicationDesc is the client for interacting with the ApplicationDesc builders.
	ApplicationDesc *ApplicationDescClient
	// Component is the client for interacting with the Component builders.
	Component *ComponentClient
	// DeploymentProfile is the client for interacting with the DeploymentProfile builders.
	DeploymentProfile *DeploymentProfileClient
	// Host is the client for interacting with the Host builders.
	Host *HostClient
	// Orchestrator is the client for interacting with the Orchestrator builders.
	Orchestrator *OrchestratorClient
	// Site is the client for interacting with the Site builders.
	Site *SiteClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ApplicationDesc = NewApplicationDescClient(c.config)
	c.Component = NewComponentClient(c.config)
	c.DeploymentProfile = NewDeploymentProfileClient(c.config)
	c.Host = NewHostClient(c.config)
	c.Orchestrator = NewOrchestratorClient(c.config)
	c.Site = NewSiteClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		ApplicationDesc:   NewApplicationDescClient(cfg),
		Component:         NewComponentClient(cfg),
		DeploymentProfile: NewDeploymentProfileClient(cfg),
		Host:              NewHostClient(cfg),
		Orchestrator:      NewOrchestratorClient(cfg),
		Site:              NewSiteClient(cfg),
		User:              NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		ApplicationDesc:   NewApplicationDescClient(cfg),
		Component:         NewComponentClient(cfg),
		DeploymentProfile: NewDeploymentProfileClient(cfg),
		Host:              NewHostClient(cfg),
		Orchestrator:      NewOrchestratorClient(cfg),
		Site:              NewSiteClient(cfg),
		User:              NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ApplicationDesc.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ApplicationDesc, c.Component, c.DeploymentProfile, c.Host, c.Orchestrator,
		c.Site, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ApplicationDesc, c.Component, c.DeploymentProfile, c.Host, c.Orchestrator,
		c.Site, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ApplicationDescMutation:
		return c.ApplicationDesc.mutate(ctx, m)
	case *ComponentMutation:
		return c.Component.mutate(ctx, m)
	case *DeploymentProfileMutation:
		return c.DeploymentProfile.mutate(ctx, m)
	case *HostMutation:
		return c.Host.mutate(ctx, m)
	case *OrchestratorMutation:
		return c.Orchestrator.mutate(ctx, m)
	case *SiteMutation:
		return c.Site.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ApplicationDescClient is a client for the ApplicationDesc schema.
type ApplicationDescClient struct {
	config
}

// NewApplicationDescClient returns a client for the ApplicationDesc from the given config.
func NewApplicationDescClient(c config) *ApplicationDescClient {
	return &ApplicationDescClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `applicationdesc.Hooks(f(g(h())))`.
func (c *ApplicationDescClient) Use(hooks ...Hook) {
	c.hooks.ApplicationDesc = append(c.hooks.ApplicationDesc, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `applicationdesc.Intercept(f(g(h())))`.
func (c *ApplicationDescClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApplicationDesc = append(c.inters.ApplicationDesc, interceptors...)
}

// Create returns a builder for creating a ApplicationDesc entity.
func (c *ApplicationDescClient) Create() *ApplicationDescCreate {
	mutation := newApplicationDescMutation(c.config, OpCreate)
	return &ApplicationDescCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApplicationDesc entities.
func (c *ApplicationDescClient) CreateBulk(builders ...*ApplicationDescCreate) *ApplicationDescCreateBulk {
	return &ApplicationDescCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApplicationDescClient) MapCreateBulk(slice any, setFunc func(*ApplicationDescCreate, int)) *ApplicationDescCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApplicationDescCreateBulk{err: fmt.Errorf("calling to ApplicationDescClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApplicationDescCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApplicationDescCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApplicationDesc.
func (c *ApplicationDescClient) Update() *ApplicationDescUpdate {
	mutation := newApplicationDescMutation(c.config, OpUpdate)
	return &ApplicationDescUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApplicationDescClient) UpdateOne(_m *ApplicationDesc) *ApplicationDescUpdateOne {
	mutation := newApplicationDescMutation(c.config, OpUpdateOne, withApplicationDesc(_m))
	return &ApplicationDescUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApplicationDescClient) UpdateOneID(id string) *ApplicationDescUpdateOne {
	mutation := newApplicationDescMutation(c.config, OpUpdateOne, withApplicationDescID(id))
	return &ApplicationDescUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApplicationDesc.
func (c *ApplicationDescClient) Delete() *ApplicationDescDelete {
	mutation := newApplicationDescMutation(c.config, OpDelete)
	return &ApplicationDescDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApplicationDescClient) DeleteOne(_m *ApplicationDesc) *ApplicationDescDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApplicationDescClient) DeleteOneID(id string) *ApplicationDescDeleteOne {
	builder := c.Delete().Where(applicationdesc.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApplicationDescDeleteOne{builder}
}

// Query returns a query builder for ApplicationDesc.
func (c *ApplicationDescClient) Query() *ApplicationDescQuery {
	return &ApplicationDescQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApplicationDesc},
		inters: c.Interceptors(),
	}
}

// Get returns a ApplicationDesc entity by its id.
func (c *ApplicationDescClient) Get(ctx context.Context, id string) (*ApplicationDesc, error) {
	return c.Query().Where(applicationdesc.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApplicationDescClient) GetX(ctx context.Context, id string) *ApplicationDesc {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeploymentProfiles queries the deployment_profiles edge of a ApplicationDesc.
func (c *ApplicationDescClient) QueryDeploymentProfiles(_m *ApplicationDesc) *DeploymentProfileQuery {
	query := (&DeploymentProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(applicationdesc.Table, applicationdesc.FieldID, id),
			sqlgraph.To(deploymentprofile.Table, deploymentprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, applicationdesc.DeploymentProfilesTable, applicationdesc.DeploymentProfilesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ApplicationDescClient) Hooks() []Hook {
	return c.hooks.ApplicationDesc
}

// Interceptors returns the client interceptors.
func (c *ApplicationDescClient) Interceptors() []Interceptor {
	return c.inters.ApplicationDesc
}

func (c *ApplicationDescClient) mutate(ctx context.Context, m *ApplicationDescMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApplicationDescCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApplicationDescUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApplicationDescUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApplicationDescDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApplicationDesc mutation op: %q", m.Op())
	}
}

// ComponentClient is a client for the Component schema.
type ComponentClient struct {
	config
}

// NewComponentClient returns a client for the Component from the given config.
func NewComponentClient(c config) *ComponentClient {
	return &ComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `component.Hooks(f(g(h())))`.
func (c *ComponentClient) Use(hooks ...Hook) {
	c.hooks.Component = append(c.hooks.Component, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `component.Intercept(f(g(h())))`.
func (c *ComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Component = append(c.inters.Component, interceptors...)
}

// Create returns a builder for creating a Component entity.
func (c *ComponentClient) Create() *ComponentCreate {
	mutation := newComponentMutation(c.config, OpCreate)
	return &ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Component entities.
func (c *ComponentClient) CreateBulk(builders ...*ComponentCreate) *ComponentCreateBulk {
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ComponentClient) MapCreateBulk(slice any, setFunc func(*ComponentCreate, int)) *ComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ComponentCreateBulk{err: fmt.Errorf("calling to ComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Component.
func (c *ComponentClient) Update() *ComponentUpdate {
	mutation := newComponentMutation(c.config, OpUpdate)
	return &ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentClient) UpdateOne(_m *Component) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponent(_m))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentClient) UpdateOneID(id uint) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponentID(id))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Component.
func (c *ComponentClient) Delete() *ComponentDelete {
	mutation := newComponentMutation(c.config, OpDelete)
	return &ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ComponentClient) DeleteOne(_m *Component) *ComponentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ComponentClient) DeleteOneID(id uint) *ComponentDeleteOne {
	builder := c.Delete().Where(component.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDeleteOne{builder}
}

// Query returns a query builder for Component.
func (c *ComponentClient) Query() *ComponentQuery {
	return &ComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a Component entity by its id.
func (c *ComponentClient) Get(ctx context.Context, id uint) (*Component, error) {
	return c.Query().Where(component.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentClient) GetX(ctx context.Context, id uint) *Component {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeploymentProfile queries the deployment_profile edge of a Component.
func (c *ComponentClient) QueryDeploymentProfile(_m *Component) *DeploymentProfileQuery {
	query := (&DeploymentProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(deploymentprofile.Table, deploymentprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, component.DeploymentProfileTable, component.DeploymentProfileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentClient) Hooks() []Hook {
	return c.hooks.Component
}

// Interceptors returns the client interceptors.
func (c *ComponentClient) Interceptors() []Interceptor {
	return c.inters.Component
}

func (c *ComponentClient) mutate(ctx context.Context, m *ComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Component mutation op: %q", m.Op())
	}
}

// DeploymentProfileClient is a client for the DeploymentProfile schema.
type DeploymentProfileClient struct {
	config
}

// NewDeploymentProfileClient returns a client for the DeploymentProfile from the given config.
func NewDeploymentProfileClient(c config) *DeploymentProfileClient {
	return &DeploymentProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deploymentprofile.Hooks(f(g(h())))`.
func (c *DeploymentProfileClient) Use(hooks ...Hook) {
	c.hooks.DeploymentProfile = append(c.hooks.DeploymentProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deploymentprofile.Intercept(f(g(h())))`.
func (c *DeploymentProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeploymentProfile = append(c.inters.DeploymentProfile, interceptors...)
}

// Create returns a builder for creating a DeploymentProfile entity.
func (c *DeploymentProfileClient) Create() *DeploymentProfileCreate {
	mutation := newDeploymentProfileMutation(c.config, OpCreate)
	return &DeploymentProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeploymentProfile entities.
func (c *DeploymentProfileClient) CreateBulk(builders ...*DeploymentProfileCreate) *DeploymentProfileCreateBulk {
	return &DeploymentProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentProfileClient) MapCreateBulk(slice any, setFunc func(*DeploymentProfileCreate, int)) *DeploymentProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentProfileCreateBulk{err: fmt.Errorf("calling to DeploymentProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeploymentProfile.
func (c *DeploymentProfileClient) Update() *DeploymentProfileUpdate {
	mutation := newDeploymentProfileMutation(c.config, OpUpdate)
	return &DeploymentProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentProfileClient) UpdateOne(_m *DeploymentProfile) *DeploymentProfileUpdateOne {
	mutation := newDeploymentProfileMutation(c.config, OpUpdateOne, withDeploymentProfile(_m))
	return &DeploymentProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentProfileClient) UpdateOneID(id string) *DeploymentProfileUpdateOne {
	mutation := newDeploymentProfileMutation(c.config, OpUpdateOne, withDeploymentProfileID(id))
	return &DeploymentProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeploymentProfile.
func (c *DeploymentProfileClient) Delete() *DeploymentProfileDelete {
	mutation := newDeploymentProfileMutation(c.config, OpDelete)
	return &DeploymentProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentProfileClient) DeleteOne(_m *DeploymentProfile) *DeploymentProfileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentProfileClient) DeleteOneID(id string) *DeploymentProfileDeleteOne {
	builder := c.Delete().Where(deploymentprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentProfileDeleteOne{builder}
}

// Query returns a query builder for DeploymentProfile.
func (c *DeploymentProfileClient) Query() *DeploymentProfileQuery {
	return &DeploymentProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeploymentProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a DeploymentProfile entity by its id.
func (c *DeploymentProfileClient) Get(ctx context.Context, id string) (*DeploymentProfile, error) {
	return c.Query().Where(deploymentprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentProfileClient) GetX(ctx context.Context, id string) *DeploymentProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a DeploymentProfile.
func (c *DeploymentProfileClient) QueryComponents(_m *DeploymentProfile) *ComponentQuery {
	query := (&ComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentprofile.Table, deploymentprofile.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deploymentprofile.ComponentsTable, deploymentprofile.ComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApplicationDesc queries the application_desc edge of a DeploymentProfile.
func (c *DeploymentProfileClient) QueryApplicationDesc(_m *DeploymentProfile) *ApplicationDescQuery {
	query := (&ApplicationDescClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deploymentprofile.Table, deploymentprofile.FieldID, id),
			sqlgraph.To(applicationdesc.Table, applicationdesc.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deploymentprofile.ApplicationDescTable, deploymentprofile.ApplicationDescColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentProfileClient) Hooks() []Hook {
	return c.hooks.DeploymentProfile
}

// Interceptors returns the client interceptors.
func (c *DeploymentProfileClient) Interceptors() []Interceptor {
	return c.inters.DeploymentProfile
}

func (c *DeploymentProfileClient) mutate(ctx context.Context, m *DeploymentProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DeploymentProfile mutation op: %q", m.Op())
	}
}

// HostClient is a client for the Host schema.
type HostClient struct {
	config
}

// NewHostClient returns a client for the Host from the given config.
func NewHostClient(c config) *HostClient {
	return &HostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `host.Hooks(f(g(h())))`.
func (c *HostClient) Use(hooks ...Hook) {
	c.hooks.Host = append(c.hooks.Host, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `host.Intercept(f(g(h())))`.
func (c *HostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Host = append(c.inters.Host, interceptors...)
}

// Create returns a builder for creating a Host entity.
func (c *HostClient) Create() *HostCreate {
	mutation := newHostMutation(c.config, OpCreate)
	return &HostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Host entities.
func (c *HostClient) CreateBulk(builders ...*HostCreate) *HostCreateBulk {
	return &HostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HostClient) MapCreateBulk(slice any, setFunc func(*HostCreate, int)) *HostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HostCreateBulk{err: fmt.Errorf("calling to HostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Host.
func (c *HostClient) Update() *HostUpdate {
	mutation := newHostMutation(c.config, OpUpdate)
	return &HostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostClient) UpdateOne(_m *Host) *HostUpdateOne {
	mutation := newHostMutation(c.config, OpUpdateOne, withHost(_m))
	return &HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostClient) UpdateOneID(id uuid.UUID) *HostUpdateOne {
	mutation := newHostMutation(c.config, OpUpdateOne, withHostID(id))
	return &HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Host.
func (c *HostClient) Delete() *HostDelete {
	mutation := newHostMutation(c.config, OpDelete)
	return &HostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HostClient) DeleteOne(_m *Host) *HostDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HostClient) DeleteOneID(id uuid.UUID) *HostDeleteOne {
	builder := c.Delete().Where(host.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostDeleteOne{builder}
}

// Query returns a query builder for Host.
func (c *HostClient) Query() *HostQuery {
	return &HostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHost},
		inters: c.Interceptors(),
	}
}

// Get returns a Host entity by its id.
func (c *HostClient) Get(ctx context.Context, id uuid.UUID) (*Host, error) {
	return c.Query().Where(host.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostClient) GetX(ctx context.Context, id uuid.UUID) *Host {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySite queries the site edge of a Host.
func (c *HostClient) QuerySite(_m *Host) *SiteQuery {
	query := (&SiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(site.Table, site.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, host.SiteTable, host.SiteColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostClient) Hooks() []Hook {
	return c.hooks.Host
}

// Interceptors returns the client interceptors.
func (c *HostClient) Interceptors() []Interceptor {
	return c.inters.Host
}

func (c *HostClient) mutate(ctx context.Context, m *HostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Host mutation op: %q", m.Op())
	}
}

// OrchestratorClient is a client for the Orchestrator schema.
type OrchestratorClient struct {
	config
}

// NewOrchestratorClient returns a client for the Orchestrator from the given config.
func NewOrchestratorClient(c config) *OrchestratorClient {
	return &OrchestratorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orchestrator.Hooks(f(g(h())))`.
func (c *OrchestratorClient) Use(hooks ...Hook) {
	c.hooks.Orchestrator = append(c.hooks.Orchestrator, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orchestrator.Intercept(f(g(h())))`.
func (c *OrchestratorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Orchestrator = append(c.inters.Orchestrator, interceptors...)
}

// Create returns a builder for creating a Orchestrator entity.
func (c *OrchestratorClient) Create() *OrchestratorCreate {
	mutation := newOrchestratorMutation(c.config, OpCreate)
	return &OrchestratorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Orchestrator entities.
func (c *OrchestratorClient) CreateBulk(builders ...*OrchestratorCreate) *OrchestratorCreateBulk {
	return &OrchestratorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrchestratorClient) MapCreateBulk(slice any, setFunc func(*OrchestratorCreate, int)) *OrchestratorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrchestratorCreateBulk{err: fmt.Errorf("calling to OrchestratorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrchestratorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrchestratorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Orchestrator.
func (c *OrchestratorClient) Update() *OrchestratorUpdate {
	mutation := newOrchestratorMutation(c.config, OpUpdate)
	return &OrchestratorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrchestratorClient) UpdateOne(_m *Orchestrator) *OrchestratorUpdateOne {
	mutation := newOrchestratorMutation(c.config, OpUpdateOne, withOrchestrator(_m))
	return &OrchestratorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrchestratorClient) UpdateOneID(id uuid.UUID) *OrchestratorUpdateOne {
	mutation := newOrchestratorMutation(c.config, OpUpdateOne, withOrchestratorID(id))
	return &OrchestratorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Orchestrator.
func (c *OrchestratorClient) Delete() *OrchestratorDelete {
	mutation := newOrchestratorMutation(c.config, OpDelete)
	return &OrchestratorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrchestratorClient) DeleteOne(_m *Orchestrator) *OrchestratorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrchestratorClient) DeleteOneID(id uuid.UUID) *OrchestratorDeleteOne {
	builder := c.Delete().Where(orchestrator.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrchestratorDeleteOne{builder}
}

// Query returns a query builder for Orchestrator.
func (c *OrchestratorClient) Query() *OrchestratorQuery {
	return &OrchestratorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrchestrator},
		inters: c.Interceptors(),
	}
}

// Get returns a Orchestrator entity by its id.
func (c *OrchestratorClient) Get(ctx context.Context, id uuid.UUID) (*Orchestrator, error) {
	return c.Query().Where(orchestrator.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrchestratorClient) GetX(ctx context.Context, id uuid.UUID) *Orchestrator {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySites queries the sites edge of a Orchestrator.
func (c *OrchestratorClient) QuerySites(_m *Orchestrator) *SiteQuery {
	query := (&SiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orchestrator.Table, orchestrator.FieldID, id),
			sqlgraph.To(site.Table, site.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orchestrator.SitesTable, orchestrator.SitesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrchestratorClient) Hooks() []Hook {
	return c.hooks.Orchestrator
}

// Interceptors returns the client interceptors.
func (c *OrchestratorClient) Interceptors() []Interceptor {
	return c.inters.Orchestrator
}

func (c *OrchestratorClient) mutate(ctx context.Context, m *OrchestratorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrchestratorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrchestratorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrchestratorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrchestratorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Orchestrator mutation op: %q", m.Op())
	}
}

// SiteClient is a client for the Site schema.
type SiteClient struct {
	config
}

// NewSiteClient returns a client for the Site from the given config.
func NewSiteClient(c config) *SiteClient {
	return &SiteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `site.Hooks(f(g(h())))`.
func (c *SiteClient) Use(hooks ...Hook) {
	c.hooks.Site = append(c.hooks.Site, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `site.Intercept(f(g(h())))`.
func (c *SiteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Site = append(c.inters.Site, interceptors...)
}

// Create returns a builder for creating a Site entity.
func (c *SiteClient) Create() *SiteCreate {
	mutation := newSiteMutation(c.config, OpCreate)
	return &SiteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Site entities.
func (c *SiteClient) CreateBulk(builders ...*SiteCreate) *SiteCreateBulk {
	return &SiteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SiteClient) MapCreateBulk(slice any, setFunc func(*SiteCreate, int)) *SiteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SiteCreateBulk{err: fmt.Errorf("calling to SiteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SiteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SiteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Site.
func (c *SiteClient) Update() *SiteUpdate {
	mutation := newSiteMutation(c.config, OpUpdate)
	return &SiteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SiteClient) UpdateOne(_m *Site) *SiteUpdateOne {
	mutation := newSiteMutation(c.config, OpUpdateOne, withSite(_m))
	return &SiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SiteClient) UpdateOneID(id uuid.UUID) *SiteUpdateOne {
	mutation := newSiteMutation(c.config, OpUpdateOne, withSiteID(id))
	return &SiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Site.
func (c *SiteClient) Delete() *SiteDelete {
	mutation := newSiteMutation(c.config, OpDelete)
	return &SiteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SiteClient) DeleteOne(_m *Site) *SiteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SiteClient) DeleteOneID(id uuid.UUID) *SiteDeleteOne {
	builder := c.Delete().Where(site.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SiteDeleteOne{builder}
}

// Query returns a query builder for Site.
func (c *SiteClient) Query() *SiteQuery {
	return &SiteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSite},
		inters: c.Interceptors(),
	}
}

// Get returns a Site entity by its id.
func (c *SiteClient) Get(ctx context.Context, id uuid.UUID) (*Site, error) {
	return c.Query().Where(site.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SiteClient) GetX(ctx context.Context, id uuid.UUID) *Site {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHosts queries the hosts edge of a Site.
func (c *SiteClient) QueryHosts(_m *Site) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(site.Table, site.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, site.HostsTable, site.HostsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrchestrator queries the orchestrator edge of a Site.
func (c *SiteClient) QueryOrchestrator(_m *Site) *OrchestratorQuery {
	query := (&OrchestratorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(site.Table, site.FieldID, id),
			sqlgraph.To(orchestrator.Table, orchestrator.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, site.OrchestratorTable, site.OrchestratorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SiteClient) Hooks() []Hook {
	return c.hooks.Site
}

// Interceptors returns the client interceptors.
func (c *SiteClient) Interceptors() []Interceptor {
	return c.inters.Site
}

func (c *SiteClient) mutate(ctx context.Context, m *SiteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SiteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SiteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SiteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Site mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ApplicationDesc, Component, DeploymentProfile, Host, Orchestrator, Site,
		User []ent.Hook
	}
	inters struct {
		ApplicationDesc, Component, DeploymentProfile, Host, Orchestrator, Site,
		User []ent.Interceptor
	}
)

// file: lo/main.go
package main

import (
	"context"
	"flag"
	"log"
	"net"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"

	"google.golang.org/grpc"
	pb "github.com/balaji-balu/margo-hello-world/proto_generated"

	"github.com/balaji-balu/margo-hello-world/pkg/deployment"
	"fmt"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	_ "github.com/lib/pq"  // enables the 'postgres' driver
	"github.com/balaji-balu/margo-hello-world/ent"
	"github.com/joho/godotenv"
	"net/http"
	"bytes"
	"encoding/json"
	"github.com/google/uuid"

	"github.com/balaji-balu/margo-hello-world/internal/orchestrator"
	cfffg "github.com/balaji-balu/margo-hello-world/internal/config"
	"github.com/balaji-balu/margo-hello-world/ent/host"
	"github.com/balaji-balu/margo-hello-world/ent/site"
)

type server struct {
	pb.UnimplementedLocalOrchestratorServer

	nodeAddr map[string]string       // nodeID -> address
	enConns  map[string]*grpc.ClientConn
	enClients map[string]pb.EdgeNodeClient

	statuses map[string]*pb.StatusReport // deploymentID -> merged statuses
	mu       sync.Mutex

	coAddr   string
	coConn   *grpc.ClientConn
	coClient pb.CentralOrchestratorClient
}

func init() {

    err:= godotenv.Load("./.env") // relative path to project root
    if err != nil {
        log.Println("No .env file found, reading from system environment")
    }
}

func newServer(nodeAddr map[string]string, coAddr string) *server {
	return &server{
		nodeAddr:  nodeAddr,
		enConns:   make(map[string]*grpc.ClientConn),
		enClients: make(map[string]pb.EdgeNodeClient),
		statuses:  make(map[string]*pb.StatusReport),
		coAddr:    coAddr,
	}
}


func (s *server) handleStatus(w http.ResponseWriter, r *http.Request) {
	var report deployment.DeploymentReport
	if err := json.NewDecoder(r.Body).Decode(&report); err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	log.Printf("[LO] Status from agent: %s - %s", report.AppName, report.Status)

	// Forward to CO
	body, _ := json.Marshal(report)
	http.Post("http://central-orchestrator:8082/status", "application/json", bytes.NewReader(body))

    // if err := lo.machine.Event(ctx, "notify_co"); err != nil {
    //     return 
    // }

    // fmt.Println("→", lo.machine.Current())

    // return lo.machine.Event(ctx, "reset")
}

func initDB() *ent.Client {
	dsn := os.Getenv("DATABASE_URL")
    // if dsn == "" {
    //     dsn = "postgres://postgres:postgres@localhost:5432/orchestration?sslmode=disable"
    // }

    fmt.Println("[CO] connecting to postgres at ", dsn)
    drv, err := sql.Open(dialect.Postgres, dsn)
    if err != nil {
        log.Fatalf("failed connecting to postgres: %v", err)
    }
    client := ent.NewClient(ent.Driver(drv))
    defer client.Close()

	return client
}
func main() {
	ctx := context.Background()

	port := flag.String("port", ":50052", "listen address")
	coAddr := flag.String("co", "localhost:50051", "central orchestrator address")
	//config := flag.String("config", "", "config file")
    //site := flag.String("site", "", "site name")
	//eoport := flag.String("eoport", ":8080", "edge orchestrator port")
	configPath := flag.String("config", "./configs/lo1.yaml", "path to config file")

	flag.Parse()

	//.Println("config:", *config, "site:", *site)

	nodeAddr := map[string]string{
		"edge1": "localhost:50054",
		"edge2": "localhost:50055",
	}

	cfg, err := cfffg.LoadConfig(*configPath)
	if err != nil {
		log.Fatalf("error loading config: %v", err)
	}

	log.Printf("✅ Loaded config: site=%s, port=%d, db URL=%s",
		cfg.Server.Site, cfg.Server.Port, cfg.Database.URL)

	// cfg, err := config.LoadConfig("./config.yaml")
	// if err != nil {
	// 	log.Fatal("failed to load config:", err)
	// }

	//fmt.Println("Starting Local Orchestrator with trigger:", cfg.Trigger.Type)
	dsn := cfg.Database.URL //os.Getenv("DATABASE_URL")

    fmt.Println("[CO] connecting to postgres at ", dsn)
    drv, err := sql.Open(dialect.Postgres, dsn)
    if err != nil {
        log.Fatalf("failed connecting to postgres: %v", err)
    }
    client := ent.NewClient(ent.Driver(drv))
    defer client.Close()

	siteUUID, err := uuid.Parse(cfg.Server.Site)
if err != nil {
    log.Fatalf("invalid site UUID: %v", err)
}
hosts, err := client.Host.
    Query().
    Where(
        host.HasSiteWith(site.IDEQ(siteUUID)),
    ).
    All(ctx)
if err != nil {
    log.Fatal(err)
}

hosturls := []string{}

for _, h := range hosts {
    fmt.Printf("Host: %s | IP: %s | Site: %s\n", h.Hostname, h.EdgeURL, cfg.Server.Site)
    hosturls = append(hosturls, h.EdgeURL) // ✅ must assign back
}

log.Println("hosts:", hosts)
log.Println("hosturls:", hosturls)



	lo := orchestrator.NewLocalOrchestrator("./configs/fsm_lo.yaml")
	lo.Hosturls = hosturls
	//lo.EOPort = *eoport

	//lo.Client = initDB()


	// ✅ Context + signal handling
	ctx, cancel := context.WithCancel(context.Background())
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-stop
		log.Println("LO: shutting down...")
		cancel()
	}()

	// ✅ Start trigger with context
	// trg := trigger.New(cfg)
	// go func() {
	// 	if err := trg.Start(ctx); err != nil {
	// 		log.Printf("trigger stopped with error: %v", err)
	// 	}
	// }()

	for {
		select {
    		case <-ctx.Done():
        		log.Println("LO: main loop exiting...")
        		return // gracefully exit main()
			default:
				mode := lo.DetectMode()
				switch mode {
				case orchestrator.PushPreferred:
					lo.WaitForWebhook(ctx)
				case orchestrator.AdaptivePull:
					lo.Poll(ctx)
				case orchestrator.OfflineDeterministic:
					lo.ScanLocalInbox(ctx)
				default:
					log.Println("Unknown mode, defaulting to AdaptivePull")
					lo.Poll(ctx)
				}
		}

        lo.PersistJournal()
        time.Sleep(5 * time.Second)
    }

	// ✅ Start gRPC server
	lis, err := net.Listen("tcp", *port)
	if err != nil {
		log.Fatalf("LO: listen error: %v", err)
	}

	srv := grpc.NewServer()
	server := newServer(nodeAddr, *coAddr)
	if err := server.initClients(); err != nil {
		log.Fatalf("LO: init clients error: %v", err)
	}

	pb.RegisterLocalOrchestratorServer(srv, server)

	go func() {
		log.Printf("LO listening on %s", *port)
		if err := srv.Serve(lis); err != nil {
			log.Fatalf("LO: serve error: %v", err)
		}
	}()

	// ✅ Wait for cancel (Ctrl+C)
	<-ctx.Done()

	// ✅ Graceful shutdown
	log.Println("LO: stopping gRPC server...")
	srv.GracefulStop()
	server.shutdown()

	time.Sleep(1 * time.Second)
	log.Println("LO: exited cleanly")
}
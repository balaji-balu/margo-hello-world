package main

import (
	"context"
	"log"
	"sync"
	"time"

	"google.golang.org/grpc"
	pb "github.com/balaji-balu/margo-hello-world/proto_generated"
	"github.com/gin-gonic/gin"
	"net/http"
)
type grpcServer struct {
	port string
}

func newGRPCServer(port , r) (*grpcServer, error) {
	return &grpcServer{port: port}, nil
}

func (s *grpcServer) start() {
	r.POST("/grpc/start", func(c *gin.Context) {
		var req struct {
			Port   string `json:"port" binding:"required"`
			CoAddr string `json:"co_addr"`
		}

		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		grpcOnce.Do(func() {
			var err error
			grpcSrv, err = newGRPCServer(req.Port)
			if err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
				return
			}
			grpcSrv.start()
		})
		c.JSON(http.StatusOK, gin.H{"status": "started", "port": req.Port})
	})
}

func (s *grpcServer) stop() {
	r.POST("/grpc/stop", func(c *gin.Context) {
		if grpcSrv != nil {
			grpcSrv.stop()
			c.JSON(http.StatusOK, gin.H{"status": "stopped"})
		} else {
			c.JSON(http.StatusBadRequest, gin.H{"error": "gRPC not running"})
		}
	})
}

//func (s *grpcServer) {} 	

// initialize persistent gRPC connections
func (s *grpcServer) initClients() error {
	for id, addr := range s.nodeAddr {
		conn, err := grpc.Dial(addr, grpc.WithInsecure())
		if err != nil {
			return err
		}
		//s.enConns[id] = conn
		//s.enClients[id] = pb.NewEdgeNodeClient(conn)
		log.Printf("LO: connected to EN %s at %s", id, addr)
	}

	connCo, err := grpc.Dial(s.coAddr, grpc.WithInsecure())
	if err != nil {
		return err
	}
	//s.coConn = connCo
	//s.coClient = pb.NewCentralOrchestratorClient(connCo)
	log.Printf("LO: connected to CO at %s", s.coAddr)
	return nil
}

func (s *grpcServer) ReceiveDeploy(ctx context.Context, req *pb.DeployRequest) (*pb.DeployResponse, error) {
	log.Printf("LO: ReceiveDeploy id=%s fleet=%s", req.DeploymentId, req.Fleet.Name)

	var wg sync.WaitGroup
	for _, node := range req.Fleet.Nodes {
		client, ok := s.enClients[node.Id]
		if !ok {
			log.Printf("LO: unknown node %s", node.Id)
			continue
		}

		per := &pb.DeployRequest{
			DeploymentId: req.DeploymentId,
			Fleet: &pb.Fleet{
				Name:  req.Fleet.Name,
				Nodes: []*pb.NodeSpec{node},
			},
		}

		wg.Add(1)
		go func(id string, c pb.EdgeNodeClient, req *pb.DeployRequest) {
			defer wg.Done()
			ctx2, cancel := context.WithTimeout(context.Background(), 20*time.Second)
			defer cancel()
			resp, err := c.ApplyDeploy(ctx2, req)
			if err != nil {
				log.Printf("LO: apply deploy to EN %s err: %v", id, err)
				return
			}
			log.Printf("LO: EN %s responded: %s", id, resp.Message)
		}(node.Id, client, per)
	}

	wg.Wait()
	return &pb.DeployResponse{DeploymentId: req.DeploymentId, Message: "deployment forwarded to edges"}, nil
}

func (s *grpcServer) ReportFromEdge(ctx context.Context, rpt *pb.StatusReport) (*pb.DeployResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	existing, ok := s.statuses[rpt.DeploymentId]
	if !ok {
		// first report
		s.statuses[rpt.DeploymentId] = rpt
	} else {
		// merge new statuses
		existing.Statuses = append(existing.Statuses, rpt.Statuses...)
	}

	go s.forwardToCO(s.statuses[rpt.DeploymentId])
	return &pb.DeployResponse{DeploymentId: rpt.DeploymentId, Message: "status stored"}, nil
}

func (s *server) forwardToCO(rpt *pb.StatusReport) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	resp, err := s.coClient.ReportStatus(ctx, rpt)
	if err != nil {
		log.Printf("LO: forward to CO err: %v", err)
		return
	}
	log.Printf("LO: forwarded status to CO: %s", resp.Message)
}

func (s *server) shutdown() {
	log.Println("LO: shutting down...")
	for _, conn := range s.enConns {
		conn.Close()
	}
	if s.coConn != nil {
		s.coConn.Close()
	}
}
